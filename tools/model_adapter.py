#!/usr/bin/env python3
import sys
import json
import time
import hashlib
import argparse
import os
import yaml
from pathlib import Path
import importlib.util

# --- 配置与策略 ---
POLICY_PATH = Path("tools/policy.yaml")

def load_policy():
    if POLICY_PATH.exists():
        return yaml.safe_load(POLICY_PATH.read_text())
    return {}

def verify_policy(phase, model):
    policy = load_policy()
    rules = policy.get('model_rules', {})
    allowed = set(rules.get(phase, []))
    if not allowed: return False

    # P1 Fix: 移除 substring 匹配，改用精确或 Vendor 前缀匹配
    norm = model.lower()
    for a in allowed:
        a = a.lower()
        # exact match or vendor-style prefix (e.g., "gpt-4", "gpt-4o/..")
        if norm == a or norm.startswith(a + "-") or norm.startswith(a + "/"):
            return True
    return False

# --- 主逻辑 ---
def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("action", choices=["call"])
    parser.add_argument("--model", required=True)
    parser.add_argument("--prompt-file", required=True)
    parser.add_argument("--out", required=True)
    parser.add_argument("--feature", required=True)
    parser.add_argument("--phase", required=True) 
    parser.add_argument("--owner", default="system")
    
    args = parser.parse_args()
    
    # 1. 策略检查
    if not verify_policy(args.phase, args.model):
        print(f"[DENY] Model {args.model} not allowed for phase {args.phase}")
        sys.exit(1)
        
    # 2. 模拟调用 (实际应集成 Provider)
    prompt = Path(args.prompt_file).read_text()
    response_content = f"# Generated by {args.model}\n# ... code ..."
    
    Path(args.out).parent.mkdir(parents=True, exist_ok=True)
    Path(args.out).write_text(response_content)
    
    # 3. 生成审计 Artifact (P1 Fix: 增加审计字段)
    metadata = json.dumps({
        "model": args.model,
        "prompt_hash": hashlib.sha256(prompt.encode()).hexdigest(),
        "provider_request_id": "simulated-req-id", # P1
        "model_version": "simulated-v1",         # P1
        "tokens_in": 100,                        # P1
        "tokens_out": 50,                        # P1
        "latency_ms": 200                        # P1
    })
    
    try:
        # 动态导入 ai_toolkit，避免 spawn 子进程
        spec = importlib.util.spec_from_file_location("ai_toolkit", "tools/ai_toolkit.py")
        ai_toolkit = importlib.util.module_from_spec(spec)
        spec.loader.exec_module(ai_toolkit)
        
        # 构造 Namespace 参数对象
        mk_args = argparse.Namespace(
            feature=args.feature,
            phase="model_call",
            owner=args.owner,
            generator=args.model,
            spec_hash="pending",
            spec_file=None,
            trace_id=None,
            metadata=metadata
        )
        ai_toolkit.cmd_make_artifact(mk_args)
    except Exception as e:
        print(f"[ERR] Failed to generate artifact via internal API: {e}")
        sys.exit(1)

if __name__ == "__main__":
    main()